<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#667eea">
    <title>éº¥å…‹é¢¨æ¸¬è©¦</title>
    <script src="js/prevent-zoom.js" defer></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { height: 100%; overflow: hidden; }
        body {
            height: 100%;
            height: 100dvh;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Microsoft JhengHei', sans-serif;
            padding: 20px;
            padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right)) max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-left));
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 { color: white; margin-bottom: 20px; }
        .back-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            margin-bottom: 15px;
            align-self: flex-start;
        }
        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 10px;
        }
        .section h3 { margin-bottom: 10px; color: #667eea; }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.2rem;
            cursor: pointer;
            margin: 5px;
        }
        button:disabled { opacity: 0.5; }
        button.recording { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        #log {
            background: #1e1e1e;
            color: #0f0;
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.85rem;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .status { font-size: 1.5rem; text-align: center; margin: 15px 0; }
        .meter-container {
            height: 30px;
            background: #ddd;
            border-radius: 15px;
            overflow: hidden;
            margin: 10px 0;
        }
        .meter {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            width: 0%;
            transition: width 0.1s;
        }
    </style>
</head>
<body>
    <a href="settings.html" class="back-btn">â† è¿”å›è¨­å®š</a>
    <h1>ğŸ¤ éº¥å…‹é¢¨è¨ºæ–·æ¸¬è©¦</h1>
    <div class="container">
        <!-- æ¸¬è©¦ 1: éº¥å…‹é¢¨æ¬Šé™ -->
        <div class="section">
            <h3>1ï¸âƒ£ éº¥å…‹é¢¨æ¬Šé™æ¸¬è©¦</h3>
            <button onclick="testMicPermission()">æ¸¬è©¦éº¥å…‹é¢¨æ¬Šé™</button>
            <div id="permissionStatus" class="status">å°šæœªæ¸¬è©¦</div>
        </div>

        <!-- æ¸¬è©¦ 2: éŸ³é‡åµæ¸¬ -->
        <div class="section">
            <h3>2ï¸âƒ£ éŸ³é‡åµæ¸¬ï¼ˆèªªè©±çœ‹çœ‹éŸ³é‡æ¢æœ‰æ²’æœ‰å‹•ï¼‰</h3>
            <button onclick="startVolumeMeter()" id="volumeBtn">é–‹å§‹åµæ¸¬éŸ³é‡</button>
            <div class="meter-container">
                <div class="meter" id="volumeMeter"></div>
            </div>
            <div id="volumeStatus" class="status">å°šæœªé–‹å§‹</div>
        </div>

        <!-- æ¸¬è©¦ 3: Web Speech API -->
        <div class="section">
            <h3>3ï¸âƒ£ èªéŸ³è¾¨è­˜æ¸¬è©¦ï¼ˆèªªä»»ä½•è©±ï¼‰</h3>
            <button onclick="testSpeechRecognition()" id="speechBtn">é–‹å§‹èªéŸ³è¾¨è­˜</button>
            <div id="speechStatus" class="status">å°šæœªé–‹å§‹</div>
            <div id="speechResult" style="margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 5px; display: none;"></div>
        </div>

        <!-- æ—¥èªŒ -->
        <div class="section">
            <h3>ğŸ“‹ è¨ºæ–·æ—¥èªŒ</h3>
            <button onclick="document.getElementById('log').textContent = ''">æ¸…é™¤æ—¥èªŒ</button>
            <div id="log"></div>
        </div>
    </div>

    <script>
        let audioContext, analyser, microphone, volumeInterval;
        let recognition;

        function log(msg) {
            const logEl = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            logEl.textContent += `[${time}] ${msg}\n`;
            logEl.scrollTop = logEl.scrollHeight;
            console.log(msg);
        }

        // æ¸¬è©¦ 1: éº¥å…‹é¢¨æ¬Šé™
        async function testMicPermission() {
            log('æ¸¬è©¦éº¥å…‹é¢¨æ¬Šé™...');
            const statusEl = document.getElementById('permissionStatus');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                log('âœ… éº¥å…‹é¢¨æ¬Šé™å·²æˆäºˆ');
                statusEl.textContent = 'âœ… æ¬Šé™å·²æˆäºˆ';
                statusEl.style.color = 'green';

                // åˆ—å‡ºéŸ³è¨Šè¼¸å…¥è£ç½®
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(d => d.kind === 'audioinput');
                log(`æ‰¾åˆ° ${audioInputs.length} å€‹éŸ³è¨Šè¼¸å…¥è£ç½®:`);
                audioInputs.forEach((d, i) => {
                    log(`  ${i+1}. ${d.label || 'æœªå‘½åè£ç½®'}`);
                });

                stream.getTracks().forEach(track => track.stop());
            } catch (err) {
                log(`âŒ éº¥å…‹é¢¨æ¬Šé™éŒ¯èª¤: ${err.name} - ${err.message}`);
                statusEl.textContent = `âŒ ${err.message}`;
                statusEl.style.color = 'red';
            }
        }

        // æ¸¬è©¦ 2: éŸ³é‡åµæ¸¬
        async function startVolumeMeter() {
            const btn = document.getElementById('volumeBtn');
            const statusEl = document.getElementById('volumeStatus');
            const meterEl = document.getElementById('volumeMeter');

            if (volumeInterval) {
                clearInterval(volumeInterval);
                volumeInterval = null;
                if (microphone) microphone.disconnect();
                if (audioContext) audioContext.close();
                btn.textContent = 'é–‹å§‹åµæ¸¬éŸ³é‡';
                btn.classList.remove('recording');
                statusEl.textContent = 'å·²åœæ­¢';
                meterEl.style.width = '0%';
                log('éŸ³é‡åµæ¸¬å·²åœæ­¢');
                return;
            }

            log('é–‹å§‹éŸ³é‡åµæ¸¬...');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);

                analyser.fftSize = 256;
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                btn.textContent = 'åœæ­¢åµæ¸¬';
                btn.classList.add('recording');

                let maxVolume = 0;
                volumeInterval = setInterval(() => {
                    analyser.getByteFrequencyData(dataArray);
                    const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                    const volume = Math.min(100, average * 1.5);
                    meterEl.style.width = volume + '%';

                    if (volume > maxVolume) {
                        maxVolume = volume;
                    }

                    if (volume > 10) {
                        statusEl.textContent = `ğŸ¤ åµæ¸¬åˆ°è²éŸ³ï¼éŸ³é‡: ${Math.round(volume)}%`;
                        statusEl.style.color = 'green';
                    } else {
                        statusEl.textContent = `ç­‰å¾…è²éŸ³... (æœ€å¤§éŸ³é‡: ${Math.round(maxVolume)}%)`;
                        statusEl.style.color = 'orange';
                    }
                }, 100);

                log('âœ… éŸ³é‡åµæ¸¬å·²å•Ÿå‹•ï¼Œè«‹èªªè©±...');
            } catch (err) {
                log(`âŒ éŸ³é‡åµæ¸¬éŒ¯èª¤: ${err.message}`);
                statusEl.textContent = `âŒ ${err.message}`;
                statusEl.style.color = 'red';
            }
        }

        // æ¸¬è©¦ 3: èªéŸ³è¾¨è­˜
        function testSpeechRecognition() {
            const btn = document.getElementById('speechBtn');
            const statusEl = document.getElementById('speechStatus');
            const resultEl = document.getElementById('speechResult');

            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                log('âŒ æ­¤ç€è¦½å™¨ä¸æ”¯æ´ Web Speech API');
                statusEl.textContent = 'âŒ ç€è¦½å™¨ä¸æ”¯æ´';
                statusEl.style.color = 'red';
                return;
            }

            if (recognition) {
                recognition.stop();
                recognition = null;
                btn.textContent = 'é–‹å§‹èªéŸ³è¾¨è­˜';
                btn.classList.remove('recording');
                log('èªéŸ³è¾¨è­˜å·²åœæ­¢');
                return;
            }

            log('åˆå§‹åŒ–èªéŸ³è¾¨è­˜...');

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.lang = 'zh-TW';
            recognition.continuous = false;
            recognition.interimResults = true;
            recognition.maxAlternatives = 3;

            recognition.onstart = () => {
                log('ğŸ¤ èªéŸ³è¾¨è­˜å·²é–‹å§‹');
                statusEl.textContent = 'ğŸ¤ æ­£åœ¨è†è½...';
                statusEl.style.color = 'blue';
                btn.textContent = 'åœæ­¢è¾¨è­˜';
                btn.classList.add('recording');
            };

            recognition.onaudiostart = () => {
                log('ğŸ”Š éŸ³è¨Šè¼¸å…¥é–‹å§‹');
            };

            recognition.onsoundstart = () => {
                log('ğŸ”‰ åµæ¸¬åˆ°è²éŸ³');
            };

            recognition.onspeechstart = () => {
                log('ğŸ—£ï¸ åµæ¸¬åˆ°èªéŸ³');
                statusEl.textContent = 'ğŸ—£ï¸ è½åˆ°ä½ åœ¨èªªè©±...';
            };

            recognition.onspeechend = () => {
                log('ğŸ”‡ èªéŸ³çµæŸ');
                statusEl.textContent = 'ğŸ”„ æ­£åœ¨è¾¨è­˜...';
            };

            recognition.onsoundend = () => {
                log('ğŸ”ˆ è²éŸ³çµæŸ');
            };

            recognition.onaudioend = () => {
                log('ğŸ”Š éŸ³è¨Šè¼¸å…¥çµæŸ');
            };

            recognition.onresult = (event) => {
                const results = [];
                for (let i = 0; i < event.results.length; i++) {
                    const result = event.results[i];
                    const transcript = result[0].transcript;
                    const confidence = (result[0].confidence * 100).toFixed(1);
                    const isFinal = result.isFinal;
                    results.push({ transcript, confidence, isFinal });
                    log(`ğŸ“ çµæœ ${i+1}: "${transcript}" (ä¿¡å¿ƒåº¦: ${confidence}%, final: ${isFinal})`);
                }

                const lastResult = results[results.length - 1];
                resultEl.style.display = 'block';
                resultEl.innerHTML = `
                    <strong>è¾¨è­˜çµæœï¼š</strong> ${lastResult.transcript}<br>
                    <strong>ä¿¡å¿ƒåº¦ï¼š</strong> ${lastResult.confidence}%<br>
                    <strong>æ˜¯å¦æœ€çµ‚ï¼š</strong> ${lastResult.isFinal ? 'æ˜¯' : 'å¦ï¼ˆä¸­é–“çµæœï¼‰'}
                `;

                if (lastResult.isFinal) {
                    statusEl.textContent = 'âœ… è¾¨è­˜å®Œæˆ';
                    statusEl.style.color = 'green';
                }
            };

            recognition.onerror = (event) => {
                log(`âŒ èªéŸ³è¾¨è­˜éŒ¯èª¤: ${event.error}`);
                statusEl.textContent = `âŒ éŒ¯èª¤: ${event.error}`;
                statusEl.style.color = 'red';
                btn.textContent = 'é–‹å§‹èªéŸ³è¾¨è­˜';
                btn.classList.remove('recording');

                if (event.error === 'no-speech') {
                    log('æç¤ºï¼šæ²’æœ‰åµæ¸¬åˆ°èªéŸ³ï¼Œå¯èƒ½æ˜¯éº¥å…‹é¢¨æ²’æœ‰æ”¶åˆ°è²éŸ³');
                } else if (event.error === 'audio-capture') {
                    log('æç¤ºï¼šç„¡æ³•æ•ç²éŸ³è¨Šï¼Œè«‹æª¢æŸ¥éº¥å…‹é¢¨è¨­å®š');
                } else if (event.error === 'not-allowed') {
                    log('æç¤ºï¼šéº¥å…‹é¢¨æ¬Šé™è¢«æ‹’çµ•');
                }
            };

            recognition.onend = () => {
                log('ğŸ”š èªéŸ³è¾¨è­˜çµæŸ');
                btn.textContent = 'é–‹å§‹èªéŸ³è¾¨è­˜';
                btn.classList.remove('recording');
                recognition = null;
            };

            try {
                recognition.start();
            } catch (err) {
                log(`âŒ å•Ÿå‹•å¤±æ•—: ${err.message}`);
            }
        }

        // é é¢è¼‰å…¥æ™‚é¡¯ç¤ºç€è¦½å™¨è³‡è¨Š
        window.onload = () => {
            log('=== éº¥å…‹é¢¨è¨ºæ–·å·¥å…· ===');
            log(`ç€è¦½å™¨: ${navigator.userAgent}`);
            log(`Web Speech API: ${('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) ? 'æ”¯æ´' : 'ä¸æ”¯æ´'}`);
            log(`MediaDevices API: ${('mediaDevices' in navigator) ? 'æ”¯æ´' : 'ä¸æ”¯æ´'}`);
            log('');
            log('è«‹ä¾åºåŸ·è¡Œæ¸¬è©¦ 1ã€2ã€3');
        };
    </script>
</body>
</html>
